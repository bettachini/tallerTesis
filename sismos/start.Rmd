---
title: "Taller de tesis - Sismos"
author: "Víctor A. Bettachini"
date: "junio de 2024"
output:
  html_document
---

# R restart
```{r restart R}
# System("R")
```

# Capítulo 1: Introducción

## Contexto y motivación científica
Ver manuscrito.

## Objetivo del trabajo / pregunta
Ver manuscrito.


Encontrar los parámetros que más pesan en la percepción de un sismo en Argentina.

Para eso pienso primero probar un modelo de regresión lineal con la variable `Percibido` como dependiente y las demás como independientes.

Algo que me encantaría es factorizar la distancia entre el observador y la coordenada del sismo.
Solo tengo la columna `Provincia`, ¿será la del observador o la del sismo?



## Estructura del documento
Ver manuscrito.



# Capítulo 2: Marco teórico


# Capítulo 3: Metodología

## Presentación y descripción de los datos utilizados
Ver manuscrito.

Elaborados a partir de lo publicado por el [Instituto Nacional de Prevención Sísmica (INPRES)](http://www.inpres.gob.ar/)  
Sistematizados por Daniela Parada del Instituto de cálculo, FCEyN, UBA. [Presentamos un ejemplo para visualización de datos de sismos de Argentina de los últimos 10 años.](https://daniellaparada.github.io/IC-datasets-docencia/04_visualizacion.html) 




## Preprocesamiento y limpieza de los datos


### Carga de los datos

Determino directorios de trabajo según entorno de ejecución.
```{r Directorio de trabajo: ¿Local o GitHub Codespaces?}
if (
  dir.exists(
    file.path(
      "/workspaces"
    )
  )
) {
  setwd("/workspaces/EEA-2023/trabajos_practicos/tp1")
} else {
  setwd(
    "/home/vbettachini/documents/universitet/FCEyN/maestríaDatos/tallerTesis/sismos"
  )
}
```

```{r carga datosIC}
# No funcionó el obtener los datos tras cargar la biblioteca datosIC

# require(devtools)
# devtools::install_github("daniellaparada/datosIC")
# library(datosIC)
# datos <- sismos
# data(sismos)
```



Tras descargar al directorio local el archivo `sismos-arg.csv` desde el url `https://github.com/daniellaparada/IC-datasets-docencia/blob/main/fuente/04_visualizacion/sismos-arg.csv` lo cargo en la data.table `sismos_arg`.

```{r carga data.table , warning=F, message=F}
if (!require("data.table")) {
  install.packages("data.table")
}
library("data.table")
```

Genero la data.table a partir del archivo ubicado en el sendero (path) del sistema de archivos local.
```{r Lectura del archivo}
sismos_all <- fread("./sismos_all.csv", sep = ",") # este no tiene la columna de si fue percibido
sismos_arg <- fread("./sismos-arg.csv", sep = ",")
```


### Limpieza de datos 


#### Inspección de tipos de datos
Se verifica que se cargó

```{r head de la data.table}
head(sismos_all)
```
En `sismos_all`  los formatos son distintos, pero crucialmente no figura la columna de si fue percibido.

```{r nombres columnas iguales a publicado}
colnames(sismos_arg)
```
Aquí si figura el booleano de si fue percibido

```{r tipo de dato}
str(sismos_arg)
```



#### Valores faltantes o duplicados
```{r datos faltantes}
sum(is.na(sismos_arg))
```
No hay registros con "no números" ("not a number" o NA).

```{r datos con cero}
# check at each column for any instance of 0
sapply(sismos_arg, function(x) sum(x == 0))
```

```{r registros igulas a cero}
# show rows with Profundidad == 0
sismos_arg[Profundidad == 0]
```


```{r datos duplicados número}
nrow(sismos_arg)
duplicados <- sismos_arg[duplicated(sismos_arg, fromLast = TRUE)]
#length duplicados
c(nrow(duplicados), nrow(sismos_arg), nrow(duplicados)/nrow(sismos_arg) )
```
Esos 23 registros son un 0.04% de los 55817 registros.

```{r datos duplicados todas las ocurrencias}
# find out whether two rows are equal
all_duplicates <- sismos_arg[duplicated(sismos_arg) | duplicated(sismos_arg, fromLast = TRUE)]
all_duplicates
```

```{r sin duplicados}
sismos <- sismos_arg[!duplicated(sismos_arg)]
```
En `sismos` queda un data.table sin duplicados.


#### Datos atípicos
Ver sección de Análisis exploratorio de datos.


### Modificaciones de los datos (ingeniería de características)


#### Decimalización de la hora
```{r función de decimalización de la hora}
# Function to convert hh:mm:ss to seconds past midnight
convert_to_seconds <- function(time_str) {
  time_posix <- strptime(time_str, format="%H:%M:%S")
  seconds <- as.numeric(format(time_posix, "%H")) * 3600 +
             as.numeric(format(time_posix, "%M")) * 60 +
             as.numeric(format(time_posix, "%S"))
  return(seconds)
}
```

```{r aplicación de la función}
# Apply the function to the time_str column
sismos[, Hora_decimal := sapply(Hora, convert_to_seconds)]
# Print the result
head(sismos)
```

```{r descripción de la nueva columna}
summary(sismos$Hora_decimal)
```


## Recorte por produndidad

```{r histograma de Profundidad}
hist(sismos$Profundidad, main = "Histograma de Profundidad", xlab = "Profundidad", ylab = "Frecuencia", breaks = 50)
# save the plot
png("histograma_profundidad.png")
```

```{r histograma de Profundidad con barras más finas}
hist(sismos[Profundidad < 50]$Profundidad, main = "", xlab = "Profundidad [km]", ylab = "Frecuencia", breaks = 50)
profundidad_menos50 <- recordPlot()
png("graphs/histograma_profundidad_menos50.png", width = 400, height = 400, res = 100)
replayPlot(profundidad_menos50)
dev.off()
```

```{r solo registros con profundidad no nula}
# copy of data.table
sismos_todasProfundidades <- copy(sismos)
sismos <- sismos[Profundidad > 0]
```


#### Linealización de la magnitud
Puesto que la escala de Richter es una escala logarítmica me interesaría pasarla a una escala lineal.

> The Richter magnitude of an earthquake is determined from the logarithm of the amplitude of waves recorded by seismographs. Adjustments are included to compensate for the variation in the distance between the various seismographs and the epicenter of the earthquake. The original formula is:
> $$
> M_\mathrm{L} = \log_{10} A - \log_{10} A_\mathrm{0}(\delta) = \log_{10} [A / A_\mathrm{0}(\delta)]
> $$
> 
> Fuente: https://en.wikipedia.org/wiki/Richter_scale

La presunción es que el umbral de percepción estará ligado a la amplitud de oscilación de las ondas sísmicas.  
Aunque también podría pensarse que sería con su potencia, es decir algo proporcional a $A^2$.  
Algo para probar luego, por lo pronto a pasarle a una escala lineal.

Sin ponerme a investigar más genero una columna de magnitud_lineal con $10^{M_L}$

```{r Linealizar la escala de Richter}
sismos[, proxy_amplitud := 10^(Magnitud- 7.0)]
```

```{r head de la data.table tras generar proxy_amplitud}
head(sismos)
```

```{r descripción para magnitud lineal}
summary(sismos$proxy_amplitud)
```



# Análisis exploratorio de datos
Una básica estadística descriptiva de los datos
```{r resumen de la data.table}
summary(sismos)
```
Hay un fuerte desbalance en la variable `percibido` que indica si el sismo fue percibido o no hacia este último caso.
  
```{r fracción de no percibidos}
sum(sismos$Percibido == "FALSE") / nrow(sismos)
```


## Magnitud: distribución lineal y escala de Richter

```{r histograma de Magnitud con barras más finas}
hist(sismos$Magnitud, main = "Histograma de Magnitud", xlab = "Magnitud", ylab = "Frecuencia", breaks = 50)
# save the plot
png("graphs/histograma_magnitud.png")
```

```{r acumulado anuales por magnitud}
library(dplyr)

sismos_SJ <- sismos %>%
# sismos_SJ <- sismos_SJ %>%
  mutate(Año = format(Fecha, format = "%Y"))

df <- sismos_SJ %>%
  filter(Año > 2012,
         Año < 2022) %>%
  group_by(Año, Magnitud) %>%
  summarize(n = n())


df2 <- df %>%
  group_by(Año) %>%
  arrange(-Magnitud) %>%
  summarize(Magnitud = Magnitud,
            nacum = cumsum(n))

library(plotly)

ggplotly(
  ggplot(data = df2, aes(
    x = Magnitud, y = log(nacum, 10), colour = Año, key = nacum
  )) +
    labs(x = "Magnitud [escala Richter]", y = "(Log 10) sismos") +
    geom_point() +
    theme_classic(),
  source = "select",
  tooltip = c("key")
)

# # save as pdf
# ggsave("graphs/acumulado_anual_magnitud.pdf", width = 12, height = 6, units = "cm")

# install.packages('tikzDevice')
library(tikzDevice)
tikz('graphs/acumulado_anual_magnitud.tex',width=5,height=2)
# plot(1,main='Hello World!')
ggplot(data = df2, aes(x = Magnitud, y = log(nacum, 10), colour = Año)) +
  labs(x = "Magnitud [escala Richter]", y = "(Log 10) sismos") +
  geom_point() +
  theme_classic()
dev.off()
```



### Horario de los percibidos
```{r percibidos segmentados por hora}
# Create two separate data.tables for TRUE and FALSE cases
dt_true <- sismos[Percibido == TRUE]
dt_false <- sismos[Percibido == FALSE]

# Define the breaks for the 24 hours of the day (0 to 86400 seconds)
breaks <- seq(0, 86400, by = 3600)

# Create histograms for TRUE and FALSE cases
hist_true <- hist(dt_true$Hora_decimal, breaks = breaks, plot = FALSE)
hist_false <- hist(dt_false$Hora_decimal, breaks = breaks, plot = FALSE)

# Calculate the ratio of counts in each bin
ratio <- hist_true$counts / hist_false$counts

# Create a data.table to hold the result
percibidos_hora <- data.table(
  Hora = floor(hist_true$mids / 3600), # Convert bin midpoints to hours
  Porcentaje = ratio * 100
)

# Handle possible Inf or NA values in the ratio
percibidos_hora[is.infinite(Porcentaje) | is.na(Porcentaje), Porcentaje := NA]

# Print the result
print(percibidos_hora)
```


```{r histograma percibidos segmentados por hora}
# generate a vertical bar plot to reproduce an histogram on data at result
ggplot(percibidos_hora, aes(x = Hora, y = Porcentaje)) +
  geom_bar(stat = "identity") +
  # labs(title = "Razón de sismos percibidos a no percibidos por hora",
  labs(
       x = "Hora",
       y = "Percibidos [%]")

# save it to tikz file
tikz('graphs/histograma_percibidos_por_hora.tex',width= 4.8,height=2)
ggplot(percibidos_hora, aes(x = Hora, y = Porcentaje)) +
  geom_bar(stat = "identity") +
  labs(x = "Hora", y = "Percibidos [\\%]"
  )
dev.off()
```


### Distribución geográfica
Hay código en (https://daniellaparada.github.io/IC-datasets-docencia/04_visualizacion.html#exploraci%C3%B3n-inicial) pero se tomaron las imágenes de allí.



## Descripción de la selección de características (si corresponde)

### El problema de la distancia -> San Juan 
```{r select rows with Provincia == San Juan}
sismos_SJ <- sismos[Provincia == "San Juan", , ]
```

```{r registros SJ}
c(nrow(sismos), nrow(sismos_SJ) )
```

Quedan así un total de tres variables a trabajar en el modelo de clasificación del estado de \verb'Percibido': \verb'Hora_decimal', \verb'Profundidad' y  \verb'proxy_amplitud'.

Podría verse si hay puede hacerse un heat map de correlaciones entre estas variables con 'Percibido'.

```{r correlación variables}
# use any tool
corr_alles <- cor(sismos_SJ[, .(Hora_decimal, Profundidad, proxy_amplitud, Percibido)], use = "complete.obs")
str(corr_alles)
# only the last column
corr_alles[, 4]
```


## Descripción de las métricas de evaluación de los modelos (si corresponde)



## Descripción de los métodos estadísticos utilizados (si corresponde)
Contar sobre regresión logística aplicada a variables categóricas.

Utilizaré como base el código de Enfoque estadístico del aprendizaje, clase 9, dedicada a logit.




# Modelado

## Primer ensayo de regresión lineal
Dos histogramas superpuestos en función `magnitud_lineal` discriminados según el caso de haya o no sido `Percibido`. 

```{r biblioteca ggplot2}
library(ggplot2)
```

Lo mismo pero con rango acotado a un máximo de 1e5
  
```{r histogramas acotados}
ggplot(sismos_arg, aes(x = magnitud_lineal, fill = Percibido)) +
  geom_histogram(position = "identity", alpha = 0.5, bins = 20) +
  labs(title = "Histograma de magnitud lineal de sismos percibidos y no percibidos",
       x = "Magnitud lineal",
       y = "Frecuencia") +
  xlim(0, 1e4)
```

Poca sorpresa, obviamente la proporción de no percibidos sería dominante en los de poca intensidad.
Veré en un rango de magnitudes entre 5000 y 15000.

```{r histogramas acotados 2}
ggplot(sismos_arg, aes(x = magnitud_lineal, fill = Percibido)) +
  geom_histogram(position = "identity", alpha = 0.5, bins = 20) +
  labs(title = "Histograma de magnitud lineal de sismos percibidos y no percibidos",
       x = "Magnitud lineal",
       y = "Frecuencia") +
  xlim(5000, 50000)
```


### Algo para jugar: Ver por Provincia
Se podría ver si hay alguna provincia que tenga una mayor proporción de sismos percibidos.
Para eso necesitaría algo que ecualice la distribución de magnitudes.

1. segmentar sismos por provincias
2. elegida una provincia base, tomar su distribución de magnitudes de sismos como patrón
3. en las restantes provincias, muestrear selectivamente para que la distribución de magnitudes sea similar a la de la provincia base
4. comparar la proporción de sismos percibidos en cada provincia

```{r segmentar por provincias}
sismos_por_provincia <- sismos_arg[, .(cantidad = .N), by = Provincia]
sismos_por_provincia <- sismos_por_provincia[order(-cantidad)]
sismos_por_provincia
```

```{r histograma de cantidad de sismos por provincia}
ggplot(sismos_por_provincia, aes(x = Provincia, y = cantidad)) +
  geom_bar(stat = "identity") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Cantidad de sismos por provincia",
       x = "Provincia",
       y = "Cantidad")
```

Evidentemente es en la provincia de San Juan donde más sismos se registran.
Esa será la provincia base para la distribución de magnitudes.

```{r distribución de magnitudes en San Juan}
sismos_san_juan <- sismos_arg[Provincia == "San Juan"]
ggplot(sismos_san_juan, aes(x = magnitud_lineal)) +
  geom_histogram(position = "identity", alpha = 0.5, bins = 20) +
  labs(title = "Histograma de magnitud lineal de sismos en San Juan",
       x = "Magnitud lineal",
       y = "Frecuencia")
```

Hmmmm, no... No es la distribución. Ya sé que sigue la curva estimada de Gutenberg-Richter.
Como figura en https://daniellaparada.github.io/IC-datasets-docencia/04_visualizacion.html#exploraci%C3%B3n-inicial

> En el siguiente gráfico se superpone, en azul, la curva estimada de Gutenberg-Richter a partir de los datos de San Juan.
> $$
> \log_{10} N = a - b M,
> $$
> con $a = 6.1812$ y $b = 1.1433$.